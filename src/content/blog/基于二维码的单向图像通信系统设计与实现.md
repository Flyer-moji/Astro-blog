---
title: 基于二维码的单向图像通信系统设计与实现（发送端）
description: 本项目探索了使用二维码作为信息载体，通过摄像头接收，实现无需网络的单向数据传输机制。支持图像分段、帧同步、丢帧检测与简单纠错。核心目标是构建一个稳定的 10–18fps 通信链路，未来可扩展到文件、文本等多种数据类型传输。
pubDate: 05 23 2025
categories:
  - tech
tags:
  - opencv
  - image-communication
  - python
---
# 基于二维码的单向图像通信系统设计与实现（发送端）

前两天参加了学校的科研训练，老师发布了一个课题，要求我们做一个基于图像处理的可见光通信设计与实现，考虑到自己之前学过图像处理的理论知识，想要掌握他们还是需要一些实际的项目实践，于是我便开始了这项课题的研究。


## 项目目标

本项目的目标是设计并实现一个基于二维码的单向图像通信系统，通过摄像头接收，实现无需网络的单向数据传输机制。支持图像分段、帧同步、丢帧检测与简单纠错。核心目标是构建一个稳定的 10–18fps 通信链路，未来可扩展到文件、文本等多种数据类型传输。

## 项目方案

本项目使用 Python 语言进行开发，使用二维码作为信息载体，通过摄像头接收，实现无需网络的单向数据传输机制。二维码的优点是体积小、信息量大、易于携带、易于解析，可以满足本项目的需求。使用 OpenCV 库进行图像处理，可以快速实现图像分段、帧同步、丢帧检测与简单纠错。

## 构建过程 发送端

#### 切片的实现
用一个列表推导式，实现把读取的文件从头到尾按照传入的大小参数切成若干小块，形成一个列表。

```python
def read_file_to_chunks(filename, chunk_size=72):  #文件读取，切片
    with open(filename, 'rb') as f:
        data = f.read()
    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]
    print(f"[INFO] 文件大小: {len(data)} 字节, 被切分为 {len(chunks)} 块")
    return chunks
```
#### 封装结构
`[帧头 (4B)] + [原始数据块 (≤72B)] + [CRC32校验码 (4B)]`
``` python
def encode_chunk_to_qr(chunk, index):
    # 帧头 = 4字节帧号（uint32）+ 数据内容（Base64）
    header = struct.pack("I", index)
    data = header + chunk
    crc = struct.pack("I", zlib.crc32(data))
    #帧头 + 帧内容 + 校验码 = 4字节帧号+数据内容+4字节校验码
    payload = base64.b64encode(data + crc)
    ···
    ···
```

- **帧头：**   
    **struct模块**把Python数据转换成字节序列（pack）,或把字节序列解析回Python数据（unpack）常用于网络传输、文件读写、协议解析等。

    这里的`struct.pack` 用于将 Python 的数据类型转换成字节流（bytes），用于二进制数据的打包和网络通信、文件存储等。`struct.pack("I", index)` 将这个`index`整数转换成4个字节的二进制形式（无符号整型，4字节,由标识符`I`表示），`index`是这一帧的序号，由下文的`generate_qr_frames()`函数生成。这就是“帧头”

- **帧尾:**   
    **CRC32校验码** 是一种将任意长度数据映射为 32位无符号整数（4字节） 的算法，这个整数就是“数据的指纹”。
    如果数据稍有改动，指纹也会完全不同，因此可以用来检测数据是否发生了错误。它本质上是对二进制数据做“多项式除法”，用固定的生成多项式（标准为 0xEDB88320）对数据进行处理，得出一个 32 位的校验值。虽然叫“除法”，但其实是位运算，非常快，而且硬件支持广泛。

    这里把帧头和数据块一块做CRC32校验，得到一个4字节的校验码，放在帧尾。这样，再接收端对帧头和数据块做同样的事，再和帧尾做比较，就可以判断数据是否完整、正确。

- **Base64 编码**  
Base64 编码是一种把二进制数据转换为 ASCII 字符串的方式，使得原本不能直接显示或传输的二进制数据可以用可见文本表示。

    为什么叫“Base64”？  
        他有自己独立的字典，对任意的六位二进制对应一个标准字符，共生成2⁶ = 64个字符。使用的字符集：
    `A-Z（26）+ a-z（26）+ 0-9（10）+ + 和 / → 共 64 个并且在结尾可能会用=作为填充符号。`

    生成逻辑：
    - 对于原始数据，把每三字节（24位）拆成4个六位，再对这四个六位进行编码，得到一个 4/3 倍长的 ASCII 字符串。
- 为什么必须用 Base64 编码？

    1. 二维码本质是文本容器二维码（尤其是用 qrcode 模块生成的）主要编码字符串数据。如果你直接把二进制数据（如 PNG、图片、压缩流）塞进去，会出现：
        - 非法字符（比如 \x00, \xFF）
        - 控制符（换行符、退格等）
        - 二维码无法生成或扫码解析失败

    2. Base64 能保证字符安全Base64 编码后，数据全部是安全、通用、不会冲突的字符。

    3. 平台无关性和容错性好,可在不同平台、语言之间无障碍传输,许多二维码扫码器对 Base64 支持良好,容易被传输协议（如 HTTP、JSON、二维码）处理。

    - ⚖️ Base64 编码的代价？
            数据大小会增加约 33%，因为每 3 字节 → 4 个字符（4/3 = 1.33）
         但为了可靠性和通用性，这是值得的代价。

- **Payload = 有效载荷**   
在数据通信、网络协议、嵌入式系统等领域，“payload”指的是：真正承载有意义内容的数据部分，不包括头部（如帧头、地址、标志）或附加校验等控制信息。虽然这个 payload 包含帧号和 CRC，但它是 这个二维码里要传递的“有效数据总内容”，就是要被编码到 QR 图像里的实际内容，所以起名为 payload 很合适。

- **QR码**   QR code，Quick Response code

    QR码是一种二维条形码，由日本 Denso Wave 公司于1994年发明。相较于传统一维条形码，它可以存储更多信息、更快读取、更强容错能力，因此被广泛应用于支付、识别、数据传输等场景。
```python
    ···
    ···
    qr = qrcode.QRCode(error_correction=qrcode.constants.ERROR_CORRECT_Q)
    #设置纠错级别为 Q（25%纠错）
    qr.add_data(payload)
    qr.make(fit=True)
    img = qr.make_image(fill_color="black", back_color="white").convert('RGB')
    return np.array(img)[:, :, ::-1]
    # PIL → OpenCV
    # BGR PIL默认是RGB，OpenCV默认是BGR，用 [:, :, ::-1] 反转通道顺序，方便用 OpenCV 处理
```

- **生成 QR 图像**  
    QR码使用 Reed-Solomon纠错，能恢复部分缺失或损坏的数据，分为四级：L（7%）、M（15%）、Q（25%）、H（30%）。

    error_correction=ERROR_CORRECT_Q：设置为 Q级纠错能力（约可容忍25%的图像损坏）。

    `fit=True` 自动选择最小版本的二维码以适配内容（1~40 版本）表示“只要刚好能装下数据就行”，生成尽可能小的二维码，提高识别速度。

- **PIL**

    是 Python 最早期用于图像处理的标准库之一，功能包括：图像打开 / 保存（支持 JPG, PNG, GIF 等格式）图像剪裁、缩放、旋转,像素操作,图像绘制（文字、线条、图形）模板匹配、滤镜、图像增强等

    PIL 最初由 Python 社区开发，但 在 2011 年停止维护。后来，社区将其 重新打包和增强，形成了一个新项目：Pillow —— 是 PIL 的“继承者”和“替代者”。

    Pillow 保留了和 PIL 完全一样的 API，几乎所有代码都可以直接用，只需要：`from PIL import Image`

    这是一个Pillow → OpenCV 的转换过程：

    img = qr.make_image(...)：这是一个 Pillow 图像（PIL.Image.Image）

    np.array(img)：转换为 NumPy 数组，变成 OpenCV 能理解的格式

    [:, :, ::-1]：将 RGB 通道反转为 BGR，以适配 OpenCV

- **生成二维码帧**

    从file_path读取文件，切分成chunk_size大小的块，调用encode_chunk_to_qr函数编码成二维码帧，返回帧列表。
```python
def generate_qr_frames(file_path, chunk_size=72):
```
- **播放二维码帧**

    调用cv2.imshow()播放二维码帧，并在左上角叠加帧序号文本。

```python
def play_qr_frames(frames, fps=12):
```

----

###### 为避免博文过长，本文只展示核心代码，完整代码请参考项目仓库。

###### 关于接收端的实现，参考[基于二维码的单向图像通信系统设计与实现（接收端）]()。 